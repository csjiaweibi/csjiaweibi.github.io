---
title: "NIO资源管理平台"
# excerpt: "Short description of portfolio item number 1<br/><img src='/images/500x300.png'>"
collection: portfolio
---

台架测试资源管理平台
使用微服务架构
基于Django+MySQL构建核心业务逻辑，利用Celery+Redis实现任务调度与缓存管理，Agent端通过RPC（Netty/rpyc）完成服务间通信，实现千级台架资源控制。
Django Restful
Agent端  client+rpc server+task schedule+monitor 
监控、日志：Prometheus、ELK
容器化：Docker、Kubernetes
任务管理：Celery
网络框架：Netty、rpyc	

原版：
项目介绍：开发公司台架(车企开发测试环境)资源管理平台，基于Django+MySQL构建核心业务逻辑，利用Celery+Redis实现定时任务与缓存管理，Agent端通过RPC完成服务间通信，实现千级台架资源控制。
开发积分系统与预约系统模块，提高台架使用率，实现精细化管理。
基于UDS协议开发诊断中间件，实现业务逻辑与底层硬件协议分离，降低系统耦合度。
使用Canal完成数据库迁移，应对数据规模增长。
使用Python结合机器学习完成台架日志分析、台架故障监控。   
总结输出8篇飞书技术文档，技术支持30+次，提出issue40+次。

改版：
主要工作：
基于UDS协议开发诊断中间件，实现业务逻辑与底层硬件协议分离，降低系统耦合度。
使用Canal完成数据库迁移，应对数据规模增长。
使用Python结合K-means完成台架日志分析、台架故障监控。 
总结输出8篇飞书技术文档，技术支持30+次，提出issue40+次。


优化grpc传输时延
uds刷写诊断中间件
定位问题


掌握基于UDS的刷写协议 基本不依赖原文可以快速识别问题  定位问题不能超过10分钟
可以基于http header,agent,payload,response code,response payload,证书等识别问题，定位问题不能超过10分钟




## 技术选型：
Django+MySQL：Django是一个强大的Web框架，适合快速开发后端逻辑；MySQL作为关系型数据库，能够高效存储结构化数据（如台架信息、预约记录）。对于千级台架，MySQL需要优化索引和分区，以应对高并发查询。
Celery+Redis：Celery用于异步任务处理（如定时检查台架状态、发送通知），Redis作为消息队列和缓存，能加速数据访问和任务调度。Redis的高性能和低延迟非常适合实时性要求高的场景。
RPC（远程过程调用）：通过RPC实现Agent端与服务端通信是明智的选择，可以确保分布式台架的控制和数据采集。常见的RPC框架如gRPC或XML-RPC可以选择，gRPC因其高性能和Protobuf支持更适合你的场景。
千级台架资源控制：千级规模意味着需要高并发处理、分布式架构和容错机制。你的方案需要结合负载均衡、微服务架构和监控系统。

为了支持千级台架，建议采用微服务架构：
将核心业务逻辑拆分为多个服务：预约服务、测试服务、诊断服务、用户管理服务。
使用消息队列（如RabbitMQ或Kafka）处理高并发请求，减轻单点压力。
部署负载均衡器（如Nginx或HAProxy）分发流量。
监控系统（如Prometheus+Grafana）跟踪系统性能和故障。



## 业务实现
业务要求：可管理、可监控、可操控、可升级

根据“可测试、可预约、可诊断”的需求，核心功能模块和实现方式如下：
(1) 可预约功能
需求：用户可以通过平台预约特定台架，查看可用时间，处理冲突。
实现：
数据库设计：在MySQL中创建Rigs表（台架信息）、Bookings表（预约记录）、Users表（用户信息）。添加索引优化查询速度。
后端逻辑：Django视图处理预约请求，检查台架状态和时间冲突。使用Django REST Framework提供API（如POST /api/bookings）。
前端：开发Web界面或移动端，支持台架列表、时间选择、冲突提示
缓存与任务：用Redis缓存热门台架的可用时间，减少数据库压力。使用Celery定时任务检查预约状态，发送提醒。
(2) 可测试功能
需求：台架能够执行测试任务，记录测试数据，并支持远程控制。
实现：
Agent端：每个台架部署一个Agent（Python或C++实现），通过RPC与中央服务器通信。Agent负责：
接收测试指令（如启动测试、停止测试）。
采集实时数据（如温度、压力、功率）。
报告状态（如正常、故障）。
RPC通信：使用gRPC，定义服务接口（如StartTest、StopTest、GetStatus）。服务器通过RPC调用Agent执行任务。
数据存储：测试数据可存入MySQL（结构化数据）或MongoDB（非结构化数据，如日志文件）。
任务调度：Celery处理测试任务的异步执行，确保千级台架的测试请求不会阻塞主线程。
(3) 可诊断功能
需求：实时监控台架状态，检测故障，生成诊断报告。
实现：
实时监控：Agent定期（每秒或每分钟）通过RPC报告台架状态（如CPU使用率、传感器数据）。服务器使用WebSocket推送状态到前端。
故障检测：基于规则或机器学习模型分析数据，判断台架是否异常。例如，若传感器数据超出阈值，触发警报。
诊断报告：Celery定时任务生成诊断报告，存储在数据库或导出为PDF。
通知：当检测到故障时，Celery触发Redis消息队列，发送邮件或短信通知相关人员。
(4)可监测
Agent采集对应数据，NEEP后端计算并分析，给到告警模块，通知到对应人员NEEP需包含，收集模块，计算分析模块，告警模块
Agent是一个运行在台架端的轻量级程序或服务，通常由软件（如Python、C++）或嵌入式系统实现。它充当台架与中央管理平台之间的桥梁，负责将台架的本地状态、数据和操作反馈给服务器，同时接收服务器下发的指令。

数据采集：从台架的传感器、控制器或硬件接口采集实时数据（如温度、压力、运行状态）。
状态报告：定期或事件触发地向服务器报告台架的当前状态（如空闲、运行、故障）。
任务执行：根据服务器的指令（如启动测试、停止测试、进行诊断），在本地执行相应的操作。
通信中枢：通过远程过程调用（RPC）或其他协议与中央服务器通信，确保分布式台架的集中管理和控制。


# 工作内容

台架：台架（Test Rig）通常是指用于模拟车辆或零部件工作环境的一种测试设备，用于验证设计、性能、耐久性等


# grpc 工作
RPC：你选择的gRPC使用高效的Protobuf序列化，延迟通常较低（比JSON-RPC或XML-RPC更优），但仍需考虑序列化/反序列化的计算开销。
gRPC默认使用HTTP/2，相比HTTP/1.1有更好的并发性和较低的头部开销。

CDN或边缘计算：如果台架分布广泛，可以部署边缘服务器，将部分RPC请求处理放在靠近Agent的节点，减少主服务器的负担。

千级台架同时调用RPC会显著增加服务器压力。以下是应对策略：

限流与排队：在服务器端实现RPC请求的限流（Rate Limiting），避免过载。使用Redis或消息队列缓冲超出的请求。
分级管理：将千级台架分组（每组百级），每个组由一个区域服务器管理，再由主服务器汇总，减少单点压力。
心跳优化：Agent的心跳间隔不要太短（如每秒一次），可以调整为每5-10秒一次，除非有紧急事件。



## UDS 协议
实现与硬件的通信（如通过串口、CAN总线或Ethernet采集数据）。
基于UDS协议开发硬件诊断中间件      实现业务逻辑与底层协议分离，降低系统耦合度   提高效率  实现远程FOTA       

UDS诊断协议    14229-1  （Unified（面向整车所有ECU） Diagnostic Services）   网络  刷写诊断相关
UDS（Unified Diagnostic Services，统一诊断服务）是一种广泛应用于汽车电子系统的诊断协议，属于ISO 14229标准的一部分。它用于车辆电子控制单元（ECU）的故障诊断、编程、参数配置等操作，是汽车售后维修、产线测试及开发阶段的核心工具之一。以下是UDS的关键要点：

​​标准化​​：基于OSI模型的应用层协议（ISO 14229），通常运行在CAN（ISO 15765-2）、DoIP（基于以太网）等底层协议上。
​​面向服务​​：通过请求-响应模式实现ECU与诊断仪（如4S店的诊断设备）的交互。
​​功能全面​​：支持诊断、ECU编程、传感器数据读取、执行器测试等。

通信机制​​
​​寻址方式​​：
​​物理寻址​​：一对一通信（诊断仪直接访问特定ECU）。
​​功能寻址​​：一对多广播（如同时唤醒多个ECU）。

CAN (ISO 15765-2, 即CAN TP)​​
​​背景​​：传统车载网络广泛使用CAN总线（带宽通常≤1Mbps），但CAN单帧只能承载8字节，而UDS消息可能更长。

DoIP (ISO 13400, 基于以太网)​​
​​背景​​：现代车载网络带宽需求增加（如自动驾驶、OTA），以太网（100Mbps以上）逐步替代CAN。
​​关键机制​​：
​​TCP/IP封装​​：UDS消息通过TCP或UDP传输，端口号通常为13400。
​​车辆发现协议​​：诊断仪通过广播或单播发现ECU的IP地址。

现代车辆通常同时支持OBD和UDS：
基于ISO 15031、SAE J1979（OBD-II）。
强制使用标准OBD-II接口（16针DLC，引脚定义固定）。
功能寻址为主（广播式请求，如模式0x01读取数据）。
OBD-II用于法规要求的排放诊断（通过标准OBD接口）。
UDS用于更深度的厂商私有诊断（可能需连接车内CAN总线或以太网）。


UDS五层结构
0x11 物理层
    物理层主要的实现可以为任何协议的硬件决定，这个是由链路层的选择支持的。例如常用CAN协议进行载体，物理层就可以使用相应的CAN芯片进行构架。如果使用LAN进行载体则也可以使用相应的芯片进行构架。
    ​​CAN总线​​：双绞线（高速CAN：500kbps，低速CAN：125kbps），终端电阻匹配（120Ω）。
    ​​以太网​​：100BASE-T1（车载以太网，单对双绞线，100Mbps）。
    ​​OBD-II接口​​：标准16针连接器（引脚定义如CAN_H、CAN_L、电源等）。

0x12 链路层
    链路层是整个协议的实现基石（从软件工程师的角度来讲），链路层定义了当前的系统基层数据定义与底层驱动的选择和编写。而整个链路层稳定性对于当前网络的实现都是非常重要的地方。其决定了数据接收的正确性与误码率，也决定的反馈码的传输正常，很多上层查询不到的问题都有可能出在这里。
    CAN（ISO 11898）​​：
    ​​帧类型​​：标准帧（11位ID）、扩展帧（29位ID）。
    ​​寻址​​：CAN ID区分物理/功能寻址（如0x7E0为诊断仪请求，0x7E8为ECU响应）。
    ​​以太网（IEEE 802.3）​​：用于DoIP，通过MAC地址和IP路由数据。

0x13 传输层（Transport Layer）​​
    ​​功能​​：处理长消息的分片与重组（因底层协议单帧容量有限）。
    ​​关键协议​​：
    ​​ISO 15765-2（CAN TP）​​：用于CAN总线上的UDS传输。
    ​​多帧传输​​：分为首帧（FF）、连续帧（CF）、流控帧（FC）。
    ​​示例​​：
    发送UDS请求0x22 F1 23（3字节）→ CAN TP拆分为：
    首帧：0x10 00 03 22 F1 23（总长度=3字节）
    连续帧：0x21 62 F1 23（响应数据）。
    ​​DoIP（ISO 13400）​​：用于以太网传输，直接封装UDS消息为TCP/IP数据包。

0x14 会话层（Session Layer）​​
    ​​功能​​：管理诊断会话状态和权限控制。
    ​​关键内容​​：
    ​​会话模式​​：
    ​​默认会话（Default Session）​​：基础权限，仅支持简单诊断。
    ​​扩展会话（Extended Session）​​：解锁更多服务（如写入数据）。
    ​​编程会话（Programming Session）​​：用于ECU刷写（需最高权限）。
    ​​定时器控制​​：如P2（响应超时时间）、S3（会话保持时间）。

0x15 应用层（Application Layer）​​
    ​​功能​​：定义诊断服务的逻辑和交互流程（核心UDS功能）。
    ​​关键内容​​：
    ​​诊断服务（SID）​​：如0x10（会话控制）、0x22（读取数据）、0x2E（写入数据）等。
    ​​请求/响应格式​​：如0x22 F1 23（请求读取数据ID 0xF123），响应0x62 F1 23 12 34。
    ​​安全访问（0x27）​​：种子-密钥认证机制。
    ​​DTC处理（0x19）​​：故障码的读取和清除。

    


​服务标识符（SID）​​：每个诊断服务对应一个唯一的SID（1字节），例如：
0x10：诊断会话控制
0x22：读取数据（如传感器值）
0x2E：写入数据（配置参数）
0x27：安全访问（解锁ECU权限）
0x3E：保持通信（防止超时）

UDS是应用层协议
 实际上该协议的应用不仅仅局限于最常见的汽车故障检测工作中（比如4S店对汽车故障的快速定位），在车载ECU间的通信、数据传输、ECU软件的升级刷写等场景中都有着广泛的应用。

    模式类型
        模式是UDS中的一个非常重要的软件抽象，UDS在应用层中抽象了3大模式：普通模式、扩展模式、编程模式。而扩展和编程模式中，又分为普通权限模式和特权模式。模式之间的主要区别如下：
        模式名称	授权模式	具有权限
        普通模式	普通权限模式	无法读取内部数据，执行较为简单的指令（重启、模式切换、会话保持）
        普通模式	特权模式	无此模式
        扩展模式	普通权限模式	可以读取内部的ECU状态值，ECU错误值，厂商SN号等
        扩展模式	特权模式	可以读写内部的ECU错误值、厂商SN号等
        编程模式	普通权限模式	可以读取一些厂商内部值
        编程模式	特权模式	可以读写厂商内部值、可以刷新当前的固件版本
        而在普通权限模式下，可以使用相应的应用层指令可以将其切换呈特权模式，但是会有自有的密钥算法进行交互，且有很严格的时序和错误次数的要求。这个我会在之后的应用层的详细讲解中进行介绍。


    诊断工具也就是下文常提到的Tester，它可以是任何实现了通信协议的东西，比如可以是一个实现了UDS协议的上位机软件、实际的硬件设备（4S店的诊断仪）甚至是一个实现了UDS协议的系统中的测试脚本。
    简言之，UDS服务主要用于诊断设备Tester（Client）和ECU（Server）之间的诊断通信，诊断设备（Tester）发送诊断请求（request），ECU给出诊断响应（response），通过这种“一问一答”的形式让目标ECU执行一些期望的操作，而UDS就是为不同类型诊断功能的request和response定义了统一的内容和格式。


    UDS诊断
        获取汽车、ECU的基本信息 VIN码  ECU软件 硬件版本  下线日期
        写入汽车的一些数据  写入VIN码  ECU的软硬件版本
        获取汽车的实时数据
        UDS
            应用层协议   ISO14229
            网络传输层 DoCAN ISO15765
            链路层、物理层


在UDS协议中，Service ID（SID）是指服务标识符，用于标识要执行的服务。每个服务都有一个唯一的SID，在诊断会话中通过SID来区分要执行/响应哪种服务请求。14229-1中定义了26种服务并将这些服务分为6大类：诊断和通信管理类、数据传输类、存储数据传输类、输入输出控制类、例程功能类、上传下载类。
    诊断和通信管理类
        诊断会话控制   10
            控制目标ECU的诊断会话状态
            Sub-Functions:
            1.     $01 Default Session
            2.     $02 Programming Session
            3.     $03 Extended Diagnostic Session
            4.     $04 Safety System Diagnostic System
            S3 Timeout：指在诊断会话中如果超时未收到新请求，系统会自动回到默认诊断会话。

        ECU复位  11
            强制让目标ECU执行复位操作
            Subfunction 01: 硬重置。

        安全访问  27
            请求解锁受保护的目标ECU
            Subfunction 07: 请求种子以达到安全级别：解锁（级别4）。
            Subfunction 08: 发送密钥以达到安全级别：解锁（级别4）。

        通讯控制  28
            控制目标ECU的通信行为  特定情况下启用或者禁用ECU的某些通信功能
            Subfunction 00 (80): 启用接收和发送。
            Subfunction 01 (81): 启用接收并禁用发送。
            Subfunction 02 (82): 禁用接收并启用发送。
            Subfunction 03 (83): 禁用接收和发送。

        待机握手  3E
            向目标ECU表明它仍然存在

        控制DTC的设置  85
            控制目标ECU中DTC的设置

        Subfunction 01 (81): 打开DTC设置。
        Subfunction 02 (82): 关闭DTC设置。

        数据传输类
            通过ID读数据  22
                客户端请求读取由提供的DID标识的记录的当前值。
                22+两个字节的DID
                示例
                22 f118

            通过ID写数据  2E
                客户端请求写入由提供的DID指定的记录数据。
                示例

            没有权限写入怎么办

        存储数据传输类
            清除诊断信息  14
                允许客户端从目标ECU清除诊断信息(包括dtc、捕获的数据等)。

            读取故障码信息 19
                    允许客户端从目标ECU请求诊断信息（包括dtc,捕获数据等）


        输入输出控制类
            通过ID控制输入输出  2f
                客户端请求控制特定于目标ECU的输入/输出。


        例程功能类
            例行程序控制  31
                客户端请求启动、停止目标ECU中的例程（简单理解就是个函数）或请求例程结果。
                Subfunction 01: 启动例程。


        上传下载类
            请求下载  34
                客户端请求协商从客户端到目标ECU的数据传输。

            数据传输  36
                客户端向目标ECU发送数据(下载)或向目标ECU请求数据(上传)。

            请求退出传输  37
                客户端请求终止数据传输




诊断请求
诊断请求是指诊断工具向车辆发送的请求消息，用于请求执行某个服务。诊断请求消息由三个部分组成：SID、子功能和实际数据。其中，SID用于标识要执行的服务，至于子功能：指的是这个服务还能更进一步的划分或者具有启动/暂停之类的子功能。
尽管服务类型不尽相同，但UDS针对这些服务定义了统一的诊断请求包的格式，每个诊断请求由1个Byte的SID + 1个Byte的 sub-function（实际上是1bit spr + 7bit sub-function，具体解释看下文）+ 不定长的实际数据构成，其格式如下所示
    sub-function具体指什么
        每个服务可能有不同的子功能，比如0x31服务用来请求ecu去执行某个预先实现的函数，其子功能可以是请求启动该函数运行，或者请求停止该函数运行。

    Tip：spr存在的目的是告诉ECU针对某个服务请求是否需要发送正响应数据，用于减少ECU发送不必要的响应，节约系统资源：
    spr=1， 抑制正响应，即ECU不给出正响应；
    spr=0， 需要ECU给出正响应，如果某个服务没有sub-function，即没有第二个字节，那默认是要发正响应的。


正响应/负响应（Positive/Negative Response）
    正相应
        诊断工具向车辆发送服务请求后，如果服务执行成功，则返回的响应消息称为正响应，反之返回的响应消息称为负响应。
        正响应报文格式
            正响应报文的字节组成格式如下所示：


    负响应报文格式
        负响应消息由两部分组成：SID和负响应码（NRC）。SID用于标识响应的服务，负响应码指示服务执行失败的原因。
        负响应报文的字节组成格式如下所示：
        NRC码
            $11: 服务不支持。
            $12: 子功能不支持。
            $13: 消息长度不正确或格式无效。
            $22: 条件不正确。
            $24: 请求序列错误。
            $31: 请求超出范围。
            $33: 安全访问被拒绝。
            $35: 无效的密钥。
            $37: 所需的时间延迟未过期。
            $70: 上传/下载未被接受。
            $71: 传输数据已挂起。
            $72: 一般编程失败。
            $73: 错误的块序列计数器。
            $7F: 服务不支持。



UDS刷写
ROP刷写
    ROP 刷写前置条件
        F100、F190(车辆配置、VIN号)已安装
        车辆防火墙已关闭，ECU页面可读取在线的ECU
        上位机(Ubuntu)配置doip， 默认ip: 172.20.1.100


逻辑地址
    分配唯一的 CAN ID： 每个 ECU 必须有唯一的物理地址（CAN ID）。

    ECU版本从哪里来
        供应商开发并提供ECU固件，状态标记为RC（Release Candidate，候选发布版本）。

    FOTA服务器与AWS的处理：
        Red dragon（红龙）：一种签名服务器，用于生成FOTA key，并对固件进行数字签名。
        FOTA Server（FOTA服务器）：
            签名后的固件上传到FOTA服务器。
            固件被加密并存储。

        AWS：云存储平台，用于托管加密后的固件

BD2  一定是来解决BD2 的一些问题
    售后诊断工具
    NDS/BD1/BD2：
        Manifest文件：FOTA服务器生成的元数据，用于描述固件内容及版本信息。
        下载加密固件：设备从AWS下载加密后的固件。
        通过DoIP（以太网）/Http或者**DoCAN（基于CAN协议）**与汽车内的模块通信。

    nTester/BD2：负责最终的固件验证和分发。

车内网络结构
    DoIP Entity（ADC/CDC/SA/LID-Main等）：多个车内模块通过DoIP协议接收固件更新。
    Gate Way（网关模块，CGW或BGW）：
        DoCAN：通过CAN网络将固件发送到传统CAN ECU。
        DoLIN：通过LIN网络传输固件到传统LIN ECU。

    传统模块（Traditional CAN ECU和LIN ECU）：通过不同协议的ECU设备，完成固件的烧录和应用。

ECU软件架构
    传统ECU软件架构图
        刷写实际上是更新boot loader 中的驱动块。application中的可执行代码块和厂商数据块
        Boot Manager（启动管理器）：
            管理系统的启动流程，包括选择加载Bootloader或Application软件。
                上电后由BootManager管理启动：
                    如果条件ProgReq = TRUE，则进入Bootloader SW。
                    如果Application SW = VALID 且 ProgReq = FALSE，则启动应用软件（Application SW）。


            Bootloader主要用于固件更新或重新编程，而Application SW处理常规诊断任务。

        Application（应用层）：
            分为多个代码块（blocks），每个block在ECU中有固定的起始地址和大小标识，刷写时通过这些标识定位对应的block。
                可执行代码块（Executable Code Block）：
                    存储应用层的功能代码，比如不同模块的程序。
                    通常对应固件包中的app文件。

                用户数据块（User Data Block）：
                    存储用户相关数据，例如配置参数、驾驶习惯数据等。

                厂商数据块（OEM Data Block）：
                    存储厂商特定的数据或校准文件（cal文件）。
                    存储重要标定数据，通常用于校准车辆性能。
                    fireware中的cal文件


            数据和程序分区可能类似于PC上的C盘（系统）和D盘（数据）。

        Bootloader（引导加载器）：
            Bootloader：引导加载程序，包含引导加载应用程序（Bootloader Application）、UDS服务层（UDS Service layer）、网络层（TP）、通信驱动（Communication Driver）。
            包含一个单独的驱动块，用于系统初始化和刷写操作。
            通常对应固件中的driver文件。


    ECU引导块结构
        引导载入：ECU应该支持一个引导加载程序和一个驻留在受保护内存空间中的引导管理器。
        引导加载程序软件：NIO要求所有CAN/Ethernet可编程ECU供应商使用NIO指定的标准flash引导加载程序软件。
        ECU刷写限制：ECU不应在引导加载程序中有限制重复刷写次数。
        NIO-TP.20.013-2019：通用UDS（统一诊断服务）诊断规范。
        NIO-TP.20.014-2019：UDS标准化诊断数据。
        ISO 15765-2：传输协议。

    Smart ECU 软件架构图
        软件结构和数据
            Boot Manager：负责在启动时决定哪个软件bank（Bank A或Bank B）将被激活。一旦一个bank被激活，另一个则处于“关机”或非活动状态。
            Bank A 和 Bank B：这两个bank互为备份，每个bank包含了该版本软件的所有功能。这种设计允许在一个bank出现问题时，另一个bank可以接管工作，确保系统的稳定性和可靠性。
            用户数据（User Data）：用户数据通常在软件更新过程中保持不变。这包括用户的账户信息、证书信息以及用户的偏好设置等。这意味着即使软件更新，用户的个性化设置和重要数据也不会丢失。
            ECU刷写过程：
                在ECU刷写时，由UDS（统一诊断服务）代理（如uds-stack）接收并校验软件包。（uds agent）
                校验无误后，诊断设备触发软件安装过程。
                如果当前工作的是Bank A，那么Bank B将被更新。
                在ECU重启前，更新脚本会将Boot Manager设置为下次从另一个bank启动，前提是安装校验通过。
                    为什么两个软件


                这种结构设计确保了Smart ECU的软件更新可以安全、可靠地进行，同时保护了用户数据不受更新过程的影响。通过双bank系统，即使在更新过程中遇到问题，车辆的关键功能也能继续运行，提高了系统的容错能力。



    刷写成功的条件
        刷写driver文件时，传数据前没有擦除动作
        刷写application文件时，传数据前有擦除动作
        数据完整性验证：
            每个block的数据传输完成后，需要使用RID 0x0202命令验证对应block的签名。
            签名验证包括：
                RSA文件：通过RSA校验加密签名文件。
                验证通过后，block才会被认为更新成功。


        分块逻辑：
            刷写时采用逐块处理方式，确保更新稳定性和数据完整性。


Pre-Programming（预编程）：包括读取ECU配置、诊断控制、读取校验和、控制DTC设置、通信控制、读取故障存储器等。
    1、预编程阶段
        在刷写前，通过刷写工具去读取 ECU 的 Boot 软件
        版本号(F180)、软件版本(F188)、 VIN(F190)、 硬件版本(F191)

    1.1打开扩展会话（10 83）
        软件一开始处于默认会话，需要发送指令让其进入扩展会话，方便后面的读写操作。

    1.2检查预编程条件（31 01 xx xx 例如31 01 02 03）
        整车厂在刷写时，会检查一些条件，当条件不满足时，退出刷写。 比如电压
        ECU 的电源电压不能太高或者太低(9V-16V)
        车辆处于 IGN On 状态， 但不在 Ready 状态
        车辆处于静止状态，车速为 0km/h 等等；
        在进行UDS刷写过程中可以通过31服务来触发内存的擦除操作等；

    1.3关闭DTC存储功能（85 82 FF FF FF ）
        在刷写过程中，ECU控制器功能不正常，可能不能收发总线消息，这种情况下，需要避免在这个过程中触发故障码存储。使用85诊断故障码设置服务设置故障码设置类型为OFF(02)关闭DTC的存储。

    1.4关闭报文通信（28 81 03  ）
        刷写过程中，因为传输的数据较多，因此停用通讯报文的发送可以降低总线负载。
        使用28服务关闭与诊断无关的报文，将节约出来的通信资源用于刷写软件，提升刷写速度。


Major-Programming（主要编程）：涉及下载数据、传输数据、请求传输块、ECU复位等。
    2 刷写中(认证&下载数据)
        刷写中首先进行身份认证，而后可以写入指纹，然后执行刷写擦除内存，向指定地址下载固件，并检查写入是否正确。

    2.1 切换到编程会话(10 02)
        刷写过程必须要在编程会话中才可以进行。使用会话控制服务 10 02 切换到 programming session。

    2.2安全访问-请求种子(27 07)。L4校验
        27 安全访问服务 保证是有权限的人员或者设备才能够进行刷写，安全访问服务子功能请求种子向 ECU 请求安全认证种子。

    2.3 安全访问-发送与验证Key(27 02)
        诊断设备收到种子后，将种子作为输入，使用双方已知的算法，计算得到Key。然后使用子功能发送秘钥将计算得到的秘钥发送给ECU。ECU使用相同的算法计算出秘钥并与收到的值进行对比，相同则认证通过。
        如果连续多次认证失败，安全访问会暂停服务一段时间。每认证失败一次，ECU安全访问失败计数器就会加1。当错误次数达到3次后，将收到0x36(尝试次数超限)的否定响应码，并延时10秒。10秒之内请求会收到0x37(延时时间未到)的否定响应码，10s之后才能再次发起认证请求。
            27 08   安全访问发送密钥（Security access send key）：使用服务ID 27 08发送安全访问的密钥。

    2.4 写入数据记录(2E F1 5A)
        记录刷写时间(F198)、写入指纹信息(F199)，标记写软件人的身份(维修店编号、诊断设备序列号)。

    2.5 擦除内存(31 01 FF 00)
        在向 ECU 的内存区域下载数据之前， 需要先擦除内存区域已有数据。
        采用 31 例程控制服务 FF00 擦除内存，根据控制器地址空间分配和芯片擦除能力，单次擦除所有或多次分段擦除。
        31 01 FF 00 擦除起始地址 擦除长度

    2.6 请求下载(34 )
        向ECU传输软件之前需要指定写入的地址和数据的大小。
        刷写设备使用 34 请求下载服务向 ECU 指定刷写起始地址和刷写数据的大小， 请求下载 ($34)服务指定的内存从起始到结束应该是连续的。如果不是连续的，刷写设备应该为每个要刷写的数据块发送一个单独的请求。
        34 数据格式标识符  地址和长度格式标识 内存地址 内存大小

    2.7 传输数据(36 XX YY YY ...)
        软件下载服务，将数据下载到上一步指定的内存中。
        刷写设备使用 36 传输数据服务向 ECU 内存区域中传输刷写的数据，一个数据块通常需要多条传输数据服务传输。
        36 数据块顺序计数器 数据

    2.8 请求传输退出 (37)
        37 服务退出当前连续内存区域的刷写，将在肯定响应中携带校验和，校验最近的一条请求下载请求服务指定的内存区域。
        返回的校验和与刷写设备计算的校验和进行比较，如果不相同，将重新使用 36 数据传输服务下载数据，多次校验不通过，刷写将会中断。

    2.9 检查存储空间(31 01 02 02)
        检验刷写的数据的可靠性，在软件/数据刷写完毕时，刷写设备通过例行程序服务来验证刷写到内存区域的每块数据是否成功。
        检查刷写的数据的完整性，确定来源合法，通过CRC、哈希、数字签名等方法，保证刷写过程中不会出错，且刷写的数据是来自合法的提供者。

    2.10 检查编程依赖(31 01 FF 01)
        使用 31 例程控制服务 FF01 确认刷入的软件和ECU的硬件，基础软件是匹配的。

    2.11 ECU复位(11 01)
        整个刷写完成后，刷写设备要求 ECU 硬件复位， ECU 进入应用程序。
        11 复位服务重启ECU，使刷写的新软件生效。


Post-Programming（后编程）：包括诊断控制、通信控制、读取校验和、ECU进入默认会话模式等。
3 刷写后(还原网络)
    刷写后的步骤与刷写前的步骤是对应的，启用刷写前禁用的通信等。
    此时网络恢复到正常的模式， ECU 以默认的波特率进行正常的通信，并能进行故障码的检测和存储。刷写结束后要求各 ECU 恢复非诊断消息的发送及接收 。

3.1 切换到扩展模式(10 03)
    默认状态下 ECU 在 01 默认会话中,使用UDS 会话切换(10 03)进入拓展会话。在拓展会话中，启用非诊断通信、清除刷写阶段产生的故障码、各 ECU 恢复故障码的检测。

3.2 启用发送一般通讯报文(28 80 03 XX XX). 开启CAN总线上NM和应用的通信
    使用 28 通信控制服务启用在刷写前停止收发的一般通讯报文。

3.3 各 ECU 恢复故障码的检测(85 01)。开启DTC设置
    恢复故障码检测，使用85诊断故障码设置服务设置故障码设置类型为ON(01)恢复DTC的存储。

3.4 ECU 回到默认模式(10 81)
    从拓展会话切换回默认会话。

证书操作
    F100和F190是VDF生成证书必要的参数，分别指车型和VIN值。
    常规刷写在刷写前务必要将证书出厂化，因为UDS刷写方式传入ECU的是RAW状态的包，只能使用dummy证书解密。这表明在刷写过程中，安全和证书管理是非常重要的。
    side-loading侧加载的固件包是从FOTA（远程固件升级）下载的，经过加密和RD签名，只能使用对应环境的证书解密。刷写前务必要确保当前证书与FOTA环境相对应。

FOTA操作
    取消FOTA？


不同车型或ECU可能需要动态启用/禁用特定UDS服务（如0x2E写入DID、0x31例程控制），若未模块化设计，会导致服务配置与业务逻辑强绑定
保证原子性



# 远程OTA怎么做的  如何保证安全
UDS提供ECU诊断和编程的标准化服务（如刷写流程0x34/0x36/0x37），但OTA需要在其上扩展​​传输、安全、调度​​等能力。

安全问题如何解决？？
远程OTA以UDS协议为基础​​，但需整合通信、安全、云端等模块，形成完整的解决方案。

安全访问  27
    请求解锁受保护的目标ECU
    Subfunction 07: 请求种子以达到安全级别：解锁（级别4）。
    Subfunction 08: 发送密钥以达到安全级别：解锁（级别4）。

FOTA服务器与AWS的处理：
        Red dragon（红龙）：一种签名服务器，用于生成FOTA key，并对固件进行数字签名。
        FOTA Server（FOTA服务器）：
            签名后的固件上传到FOTA服务器。
            固件被加密并存储。

        AWS：云存储平台，用于托管加密后的固件

远程车辆OTA（Over-The-Air）升级的安全性至关重要，一旦被攻击可能导致车辆失控、数据泄露甚至大规模召回。以下是保障OTA安全性的​​多层次技术方案​​，涵盖从云端到车端的全链路防护：

​​1. 端到端加密（E2E Encryption）​​
​​传输层安全​​：
使用​​TLS 1.3​​（HTTPS/MQTT over TLS）保护云端与车端的通信，防止中间人攻击。
禁用弱加密算法（如RC4、SHA-1），强制使用AES-256-GCM或ChaCha20-Poly1305。
​​应用层加密​​：
升级包在云端加密（如AES-256-CBC），车端通过HSM（硬件安全模块）解密。
密钥动态生成，单次有效（避免密钥复用风险）。

​​2. 数字签名与完整性校验​​
​​双重签名机制​​：
​​车企签名​​：升级包由车企私钥签名（ECDSA或RSA-PSS），车端验证公钥证书链（如X.509）。
​​Tier1签名​​：ECU供应商（如Bosch、Continental）对固件二次签名，防止车企内部恶意代码。
​​完整性校验​​：
升级包哈希值（SHA-3-256）预置在签名中，刷写前逐块校验。
ECU启动时验证固件完整性（e.g., Secure Boot）。

​​3. 安全认证与权限控制​​
​​车辆身份认证​​：
每辆车有唯一ID（如VIN码绑定证书），云端白名单控制升级权限。
车端TBOX/OTA客户端需通过双向认证（mTLS）。
​​UDS安全访问（ISO 14229-1）​​：
执行刷写前需0x27服务解锁，采用​​种子-密钥算法​​（如AES-128或HMAC-SHA256）。
密钥算法动态更新（防逆向），且与ECU硬件绑定（e.g., HSM唯一密钥）。
​​4. 防回滚（Anti-Rollback）​​
​​版本号强制递增​​：
固件版本号需严格大于当前版本（e.g., Semantic Versioning 2.1.0 → 2.1.1）。
版本号写入ECU不可篡改区域（如eFUSE或OTP内存）。
​​安全计数器​​：
每次升级递增计数器，禁止降级到旧版本（防止攻击者利用已知漏洞）。
​​5. 硬件级安全（HSM & TPM）​​
​​硬件安全模块（HSM）​​：
存储根密钥、执行加密运算（如英飞凌AURIX TC3xx系列芯片）。
物理防拆解（触发自毁机制）。
​​可信执行环境（TEE）​​：
OTA客户端运行在隔离环境（如ARM TrustZone），防止恶意软件干扰。
​​6. 入侵检测与应急响应​​
​​异常行为监控​​：
检测异常刷写请求（如频率过高、非授权ECU访问）。
车端IDS（入侵检测系统）实时上报攻击事件。
​​应急机制​​：
紧急停止升级（如电池电量低于20%时中止）。
云端远程禁用被入侵车辆（通过蜂窝网络发送Kill Switch指令）。
​​7. 合规与标准化​​
​​国际标准​​：
​​ISO/SAE 21434​​：汽车网络安全风险管理标准。
​​UNECE R155​​：强制要求车辆具备CSMS（网络安全管理系统）。
​​车企实践​​：
特斯拉：使用FOTA（Firmware-over-the-Air）时，每次升级需通过车内CAN网关验证签名。
比亚迪：升级包分片加密，且每片单独签名。


## 数据库迁移任务
完成数据迁移上云与分库分表       数据量变大了  提高查找效率    
整合 Canal + RabbitMQ 将 MySQL 增量数据（如商品、订单数据）同步到 Elasticsearch。
分库多表
    Sharding策略
    只分库：
        整个数据库读写出现性能瓶颈，例如数据库连接数被打满了（MySQL最大连接数默认150），或者并发量太大导致单个数据库已经无法满足日常的读写需求，就需要将整个库拆开。

    只分表：
        单表数据量大，读写出现瓶颈，这个表所在的库还可以支撑未来几年的增长。

    一般情况下，单表数据量到达千万级别，就可以考虑分库分表了。
    具体是否需要分库分表还是要看具体的业务场景，例如流水表、记录表，数据量非常容易到达千万级、亿万级，需要在设计数据库表的阶段就进行分表，还有一些表虽然数据量只有几百万，但字段非常多，而且有很多text、blog格式的字段，查询性能也会很慢，可以考虑分库分表。
    冷热分离：将常用的“热”数据和不常使用的“冷”数据分开存储。即在处理数据时将数据库分成冷库和热库，冷库存放那些走到终态、不常使用的数据，热库存放还需要修改、经常使用的数据。
    什么情况下可以使用冷热分离？
        数据走到终态后只有读没有写的需求。例如订单完结后基本只会读不会改。
        用户能接受新旧数据分开查询。比如有些电商网站默认只让查询3个月内的订单，如果要查询3个月前的订单，还需要访问其他的页面。

    单库单表，可以直接使用表自增主键保证全局唯一性，分库分表后，需要自己维护全局唯一的 ID，常用的算法有：UUID、号段模式（数据库生成全局 ID）、雪花算法。
    UUID 优点：
        性能非常高，本地生成，没有网络消耗；

    UUID 缺点：
        不易于存储：UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用;
        信息不安全：基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置;
        ID 作为主键时在特定的环境会存在一些问题，比如做 DB 主键的场景下，UUID 就非常不适用。


当前是储存分离的
    db master slave
    主从复制
        MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。

    实现原理
        MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志（relay log）中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。

    配置
        主服务器：
            将用户对数据库更新的操作以二进制格式保存到BinaryLog日志文件中。
            开启二进制日志
            配置唯一的server-id
            获得master二进制日志文件名及位置
            创建一个用于slave和master通信的用户账号

        从服务器：
            上面的I0进程连接上Master， 并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容。
            配置唯一的server-id
            使用master分配的用户账号读取master二进制日志
            启用slave服务


    binlog
        row 格式  行级变化    cannel 做监控分析时候使用row格式


数据迁移
    当我们数据库的数据量，增长到一定程度的时候，数据库磁盘IO压力比较大  单纯读写分离满足不了业务的需求了
        用户表  2亿用户
        日志数据 
        流水数据

    迁移
        停服迁移
        不停服迁移

    停服迁移
        准备工作
            确认数据量  
            确定分库分表的策略  确认切换的字段和分表策略
            确定目标库表的结构和数量   8个库 1024张表
            搭建新的库表  搭建目标环境
            确认分库分表中间件  ShardingSphere
            双写与校验 补偿 任务开发  做好充分测试

        迁移工作
            全量同步
            增量同步
            数据校验
            开启双写  关闭增量同步
            数据补偿  数据校验
            灰度读流量
            关闭双写  只读写 新库
            下线旧库
            整个过程要多演练  避免数据污染

        环境准备
            创建库表 
            双写  各种校验补偿任务开发

        全量同步
            业务低峰期间
            旧库
            记录mysql binlog 的位置  show master status
            开始全量数据同步
                datax 自定义插件 进行分库分表插入
                自己编写同步任务
                    同步获取记录中的最大id 与最小id
                    根据id范围分片 多任务  多线程
                        分片1 1-30000000
                            批量分页读取任务

                        分片2 30000000-1000000000
                            批量分页读取任务

                        分片3 10000000-2000000
                            批量分页读取任务


                    分库分表规则
                        批量插入任务
                        批量入库
                        插入失败
                            重试多次失败记录日志  结束后补偿



                老库到新库的数据迁移，要控制好迁移效率，解决增量数据的一致性。

            新库
            全量数据补偿任务
                假设采用异步双写方案，在迁移完成后，逐条对比新老库数据，一致则跳过，不一致则补偿：
                新库存在，老库不存在：新库删除数据
                新库不存在，老库存在：新库插入数据
                新库存在、老库存在：比较所有字段，不一致则将新库更新为老库数据


        增量同步任务
            binlog
            canal
                Canal 组件是一个基于 MVSQL 数据库增量日志解析，提供增量数据订阅和消费，支持将增量数据投递到下游消费者(如 Kafka、RocketMQ等)或者存储(如 Elasticsearch、HBase 等)的组件。
                大白话: Canal感知到MySQL数据变动，然后解析变动数据，将变动数据发送到MQ或者同步到其他数据库，等待进一步业务逻辑处理。
                工作原理
                    Canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave，向 MySQL master 发送dump 协议
                    MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )
                    ·Canal 解析 Binlog 对象(原始为 byte 流)

                数据同步
                    同步到ES   Redise等数据存储介质

                数据库实时监控
                    对于敏感数据的修改可以及时通知相关人员

                数据分析和挖掘
                    可以将mysql增量数据投递到kafka等消息队列中 为数据分析和挖掘提供数据来源

                数据库备份
                    将变动数据 迁移到备库

                数据集成
                    集成不同db  

                数据库迁移
                    完成mysql版本升级及数据迁移任务


            增量同步任务
                重试多次失败记录日志  结束后补偿


        全量校验与订正 
            批量校验  
            记录差异数据   

        抽样校验
            停机等待完成
            运行一段时间，查看binlog 位置 延迟情况
            停机前查看延迟是否在分钟以内 且数据无异常
            成功则可以切换到新库

            

    不停服迁移
        发布新版本
            由于增量同步有一定的延迟，所以不停机就要双写
            发布带有双写的代码
                双写开关
                    指定读旧库/新库
                    双写
                    指定写旧库/新库

                发布
                    订单服务
                    读写 旧库  增量同步到新库



        观察运行
            平稳运行一段时间
                监控binlog延迟情况   进行持续的全量校验与订正
                    注意对比更新时间


            持续抽样检查

        业务低峰期开启双写
            切换之后出现数据不一致的原因
                停止同步程序和开启双写，这两个过程很难做到无缝衔接
                双写的策略也不保证新旧库强一致

            记录此时binlog位置
            读数据继续旧
            写数据先走旧库事务  之后再走新库事务
                新库写入失败会写入失败日志 
                监控错误数据  
                报错超过阈值 关闭写入新库


        观察运行
            几周
            数据校验 补偿任务
            抽样检测
            监控读写需求

        灰度切读请求
            抽取灰度用户
            userId 的后四位对10000取模      0-99 读取新库   
            满满加流量 
            输出日志监控
                我的订单列表数量是否一致
                我的订单状态是否一致 
                业务方是否有反馈


        关闭双写



