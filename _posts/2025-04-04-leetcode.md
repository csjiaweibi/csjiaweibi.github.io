---
title: '我所理解的算法'
date: 2025-04-04
permalink: /posts/2025/04/blog-post-2/
tags:
  - cool posts
---

本文基于hot100

算法

# TODO
华为历年笔试  需要做

机考一共600分3道题分别为100、200、300分，主要考察范围是字符串、数组、哈希表、递归、栈、深度搜索、广度搜索、动态规划、回溯

回溯算法，回溯算法非常重要，可以用来解决很多排列组合的题，虽然回溯有点容易超时但是机测给的时间很多基本不会超时，很多题都可以用回溯暴力做出来，是解决应用题的好帮手

贪心和动态规划 内容有点多，想拿高分的话还是得看看，尤其动态规划还是会考察的，只想100分过的话，动态规划的思路也还是得稍微了解了解一下

深度搜索算法、广度搜索算法、图论 这三个考的也多




# 思想
数据结构 = 算法 +数据结构

所有的题目都是为了搜索，更快更好的搜索

# 数据结构
数据结构 :  数组 链表 树 图

数组 : 动态数组  静态数组

链表 : 双向链表  单向链表  循环链表

树 : 二叉树 平衡搜索树 满二叉树 红黑树 B+树

图 : 有向图 无向图

# 算法
算法思想 : 双指针 动态规划 滑动窗口 回溯 贪心 并查集 迪杰斯特拉算法 深度优先搜索 堆排序  广度优先搜索 模拟 前缀和

# ACM 算法历程

## 1. 核心算法与问题

### 1.1 字符串匹配、图遍历、背包问题
- **字符串匹配**：如 KMP 算法、Trie 树
- **图遍历**：BFS、DFS、拓扑排序、最短路算法
- **背包问题**：0-1 背包、完全背包

### 1.2 Java 的 `Arrays.sort()`
- 使用优化的快速排序
- 时间复杂度：O(n log n)

## 2. 字符与整数的联系——ASCII 码
- 每个常用字符对应 -128 ~ 127 的数字，可相互转化
- 负数无对应字符
- 常用 ASCII 值：
  - 'A' - 'Z'：65 ~ 90
  - 'a' - 'z'：97 ~ 122
  - '0' - '9'：48 ~ 57
- 字符可参与运算，运算时视为整数

## 3. 输入输出操作
- ACM 题目对输入输出格式和效率要求极高，使用 `Scanner` 或 `System.out.println()` 处理大规模数据可能超时（TLE）

### 3.1 高效输入输出
- **BufferedReader** 和 **BufferedWriter**：
  - `BufferedReader br = new BufferedReader(new InputStreamReader(System.in));`
  - `BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));`
- `String.valueOf(sum)`：将整数 `sum` 转换为字符串，便于输出
- 读取行：`line = br.readLine()`
- 分割字符串：`String[] numbers = line.trim().split("\\s+");`
- 解析整数：`Integer.parseInt(num)`
- 容器操作：
  - `List<Integer> path = new LinkedList<>();`
  - `path.set(j, nums[j]);`
  - `path.remove(path.size() - 1);`

### 3.2 格式化输出
- 保留四位小数：`String formattedNumber = String.format("%.4f", number);`
- 写入输出：`bw.write(formattedNumber);`
- 换行：`bw.newLine();`
- 确保输出：`bw.flush();`
- 关闭资源：`br.close();`

## 4. 常见容器
- `path = Arrays.asList(new Integer[nums.length]);`

### 4.1 Arrays 类
- 属性 `length`：返回数组长度，无括号
- `Arrays.sort()`：数组排序
- `Arrays.fill(int[] a, int val)`：填充数组
- `Arrays.toString()`：将数组转化为字符串
- `Arrays.deepToString()`：将多维数组转化为字符串（不可变长）
- 字符串转数组：使用 `Integer.parseInt()`

### 4.2 输入输出位数格式
- `%d`：整数
- `%.2f`：浮点数，保留 2 位小数

## 5. 复杂度
- 复杂度考量：1s 内约 10^8 次操作
- 数据类型：
  - `int`：2^31（约 21 亿），4 字节
  - `long`：8 字节，2^63（有符号数，约 9.2 * 10^18）

### 5.1 降低时间复杂度方法
- 预处理和缓存：计算一次，多次使用，避免重复计算；用哈希表存储中间结果
- 识别不变量：找出不同操作间保持不变的部分
- 数学分析：分析问题数学属性
- 空间换时间：使用额外数据结构（如频率表）加速计算
- 批处理思维：考虑整体关系而非独立位置
- 问题转化：将问题转化为更易解决的形式

### 5.2 实现建议
- 读取先不优化，优先实现基础功能
- 通用优化：见上

## 6. 易错点
- 不要过分节约变量
- **大整数问题**：Java 默认支持 `long` 和 `BigInteger`，优先用 `long`，必要时用 `BigInteger`
- **精度问题**：浮点数运算可能有误差，建议用 `double`，保留足够小数位

## 7. String 操作
- **字符串类**：`String`、`StringBuilder`、`StringBuffer`
- 大字符串处理：优先用 `StringBuilder`（线程不安全但高效）或 `StringBuffer`（线程安全）
- 避免多次 `+` 拼接，使用 `StringBuilder.append()`

### 7.1 示例
- 拼接：`String s4 = s1.concat(" Java");`
- 访问字符：`char c = s.charAt(1);`（索引 1 的字符）
- 子字符串：`s = s.substring(0, 5) + s.substring(12);`（删除 5 开始的 7 个字符）
- 比较：`s1.equals(s2)`
- 字符数组：`for (char ch : A.toCharArray())`

## 8. 常见考题
- 快速排序
- 堆排序
- 求子数组的最小值之和
- 重排链表
- 爬楼梯
- 完全平方数
- 链表 k 个翻转
- 模拟输出题
- 接雨水
- 回溯算法（注意特例未考虑）
- 简单题（难度和顺序不一致）
- 解析网页题
- 解析字符串题
- 模拟
- 搜索
- 生成树、连通图
- 重复元素、链表

## 9. 数据结构抽象
- 类似 Redis 数据库，提供列表、字符串、集合等数据结构，底层存储方式至少两种，根据数据实际情况选择
- **逻辑结构与存储结构**：
  - 同一逻辑结构可采用不同存储结构
  - 算法设计依赖逻辑结构，实现依赖存储结构

### 9.1 遍历与访问
- 两种形式：
  - 线性：如数组、链表
  - 非线性：如树、图

# 搜索题！！！  所有的算法题都是在搜索 在穷举

## 1. 技法

### 1.1 状态标记
- 搜索中
- 未搜索
- 搜索完成

## 2. 技巧

### 2.1 反转元素再搜索
- 常见方法

### 2.2 哈希表 O(1) 搜索
- 数组、集合、映射
- 典型问题：
  - 两数之和
  - 赎金信（数组映射）
  - 三数之和（去重逻辑）
  - 四数之和（哈希表不好剪枝，不如双指针法）

### 2.3 二分加速搜索
- 特点：有单调性一定可以二分，没有单调性可能可以二分
- 二分的本质：边界，区间可以一分为二，一边满足性质，一边不满足性质
- 常见应用：
  - 求最小的最大值
  - 求最大的最小值
  - 查找某个值
  - 查找区间第一个值
  - 查找区间最后一个值
  - 寻找到上一个区间的最大值、下一个区间的最小值，加快搜索速度

### 3.2 快速排序再搜索
- 结合快速排序的特性进行优化

### 3.3 归并排序再搜索
- 归并排序：稳定
- 典型应用：
  - 数组中的逆序对
  - 区间和的个数在某个区间

### 4.1 BFS（广度优先搜索）
- 队列实现

### 4.2 DFS（深度优先搜索）
- 栈实现

### 4.3 堆上搜
- 典型问题：
  - 数组中的第 K 个最大元素
  - 前 K 个高频元素
  - 数据流中的中位数
  - Top K 问题：
    - 第 K 个最大元素
    - 移除 K 位数字得到最小结果（栈）
    - 数组中前 K 个高频元素
    - 查找和最小的 K 对数字

### 4.4 字典序
- 典型问题：
  - 下一个排列
  - 字典序的第 K 小数字
  - 字典序排数（先序遍历）
  - 按字典序排在最后的子串

### 4.5 双指针
- 结合数组 + 哈希表 + 双指针

### 4.6 滑动窗口
- 动态窗口调整

### 4.7 前缀和
- 快速求区间和

### 4.8 借助栈与队列搜索
- 注意事项：
  - Stack, ArrayDeque, LinkedList
- 类型：
  - 用栈实现队列
  - 用队列实现栈
  - 单调栈：
    - 什么时候需要用？
    - 为每个数找出满足条件的数（比如在它左边距离最近比它小的数）
  - 优先队列：
    - 什么时候需要用？
  - 有效的括号：匹配问题都是栈的强项
  - 逆波兰表达式求值：
    - 栈与递归之间在某种程度上可以转换，逆波兰表达式相当于二叉树中的后序遍历
  - 滑动窗口最大值：
    - 单调栈、单调队列
  - 前 K 个高频元素：
    - 优先队列（披着队列外衣的堆，需要定义是大顶堆还是小顶堆）

  - 使用显式栈模拟调用栈：
    - 将递归转化为迭代形式
  - 接雨水、每日温度：
    - 单调栈


## 6. 在树上搜索

### 6.1 底层概念
- 数据量达到亿级别，主存存储不下，只能以块形式从磁盘读取数据
- 磁盘 I/O 操作耗时，B-树的主要目的是减少磁盘 I/O
- 二叉树节点深度：从根节点到该节点的最长简单路径边的条数
- 二叉树节点高度：从该节点到叶子节点的最长简单路径边的条数

### 6.2 类型

#### 6.2.1 递归
- 前序（根左右）、中序（左中右）、后序（左右中）
  - 构造二叉树（普通或搜索树）一定用前序，先构造中节点
  - 求普通二叉树属性，一般用后序，通过递归函数返回值计算
    - 需要对题目树的各种情况分类判断，详细分析
  - 求二叉搜索树属性，一定用中序，利用有序性

#### 6.2.2 迭代做法
- 递归能做的，栈也能做！
- 前序遍历：中左右，先处理中间节点，栈中先根后右再左（前序也是回溯）
- 中序遍历：借用指针遍历节点，栈处理元素
- 后序遍历：调整先序遍历顺序为中右左，再反转结果数组
- 避免递归：实际项目中尽量避免递归，防止栈溢出，参数和调用关系复杂

#### 6.2.3 层序
- 队列实现
- 典型问题：
  - 二叉树的右视图
  - 二叉树的层平均值
  - N 叉树的层序遍历（引申到图论）
  - 在每个树中找最大值
  - 填充每个节点的下一个右侧节点指针（单独处理）
  - 二叉树的最大深度：
    - 理解深度：从根节点出发
  - 二叉树的最小深度

#### 6.2.4 二叉树的性质
- 是否对称
- 最大深度：
  - 根节点的高度就是二叉树的最大深度
- 最小深度：
  - 与最大深度的差别在于处理左右孩子不为空的逻辑
- 完全二叉树节点个数：
  - 利用深度和满二叉树性质，深度用前序
- 是否平衡
- 二叉树的所有路径：
  - 递归 + 回溯
- 路径总和
- 左叶子之和：
  - 不要找错左叶子，遍历时明确条件
- 找树左下角的值：
  - 保证优先最左搜索，修改递归顺序
- 路径总和：
  - 回溯

#### 6.2.5 二叉树的改造
- 自身性质
- 翻转二叉树：
  - 理解为交换，进入前或离开后交换，中序不方便
- 对称二叉树：
  - 遍历左右子树，需要后序返回结果
- 构造二叉树：
  - 从中序与后序遍历序列构造
  - 从前序与中序遍历序列构造
  - 最大二叉树
- 合并二叉树

#### 6.2.6 二叉搜索树的性质
- 构建二叉搜索树：
  - 利用二叉搜索树性质剪枝
- 二叉搜索树中的搜索：
  - 利用中序遍历
- 验证二叉搜索树
- 二叉树与二叉搜索树的区别：
  - 属性求法不同
- 二叉搜索树的最小绝对差
- 二叉搜索树中第 K 小的数
- 二叉搜索树中的众数
- 二叉树的最近公共祖先：
  - 定义：节点 x 是 p、q 的祖先，且深度最大
  - 分类讨论
  - 需从底向上遍历，用后序（回溯）
- 二叉搜索树的最近公共祖先：
  - 利用性质，从上往下遍历
- 验证平衡二叉树：
  - 求深度用前序，求高度用后序

#### 6.2.7 二叉搜索树的操作
- 插入操作：
  - 按二叉搜索树顺序遍历
- 构建二叉搜索树（难题）
- 删除节点：
  - 涉及结构调整
- 修建二叉搜索树：
  - 需深刻理解递归，移除节点不够，还要修剪
- 将有序数组转换为二叉搜索树：
  - 构造可能自然平衡
- 把二叉搜索树转化为累加树


## 1. 在图上搜！！！

### 1.1 应用场景
- 通信网络（拓扑排序、最短路算法）
- 社交网络（深搜、广搜）
- 路径优化（最短路算法）
- 任务调度（拓扑排序）
- 生物信息学（基因为节点，基因关系为边）
- 游戏开发（A* 算法等）

### 1.2 常见算法与技术
- 深搜与广搜
- 并查集
- 最小生成树
- 拓扑排序
- 最短路算法

### 1.3 具体算法

#### 1.3.1 拓扑排序
- 用于有向无环图（DAG），确定任务或节点的线性顺序

#### 1.3.2 迪杰斯特拉（Dijkstra）找最短路
- 朴素版
- 堆优化版

#### 1.3.3 图的输入与存储
- 二维矩阵
- 邻接表

#### 1.3.4 广度优先搜索 (BFS)
- 可以搜索到最短路径

#### 1.3.5 深度优先搜索 (DFS)

#### 1.3.6 类型与问题
- 岛屿数量
- 腐烂的水果
- 所有可达路径
- 岛屿的最大面积
- 孤岛的总面积
- 沉没孤岛
- 水流问题
- 建造最大工岛
- 字符串接龙
- 有向图的完全可达性
- 岛屿的周长
- 寻找存在的路径
- 冗余连接
- 冗余连接 I
- 最小生成树：
  - Prim 算法
  - Kruskal 算法
- 最短路算法：
  - Dijkstra 朴素版
  - Dijkstra 堆优化版
  - Bellman-Ford 算法
  - SPFA 算法
  - Bellman-Ford 判断负权回路
  - Bellman-Ford 单源有限最短路
  - Floyd 算法
  - A* 算法

## 2. 在链表上搜！！！

### 2.1 注意事项
- 避免进入死循环
- 尤其注意首尾链表是否正确处理
- 注意是否需要原地修改
- 想清楚修改逻辑：先确定新指针，再修改旧指针

### 2.2 链表题技巧

#### 2.2.1 虚拟头节点
- 当头节点可能会变动时，需加虚拟头节点：`dummy = ListNode(0, head);`

#### 2.2.2 双指针
- 快慢指针
- 前后指针

#### 2.2.3 迭代
- 多用指针表示链表节点的前中后
- 注意避免死循环

#### 2.2.4 递归

### 2.3 链表题类型

#### 2.3.1 链表的操作
- 寻找链表的中点
- 翻转链表
- 删除链表重复元素 II
- 反转链表
- 链表的复制
- 链表转化为数组
- 两两交换链表中的节点
- 随机链表的复制
- 排序链表：
  - 归并排序
  - 合并两个有序链表
  - 合并 K 个升序链表

#### 2.3.2 链表的性质
- 性质题往往通过操作分析
- 回文链表
- 环形链表
- 链表的中点
- LRU 缓存：
  - 哈希表和双向链表
  - 分析哈希数据结构原理及 Java 源码
  - 哈希链表：`LinkedHashMap`
  - 双向链表 + 哈希表
- LFU 缓存：
  - 淘汰策略：淘汰使用次数最少的
  - 更难
  - 哈希链表实现

#### 2.3.3 链表的种类
- 单向链表
- 回文链表
- 双向链表

## 3. 在数组上搜

### 3.1 字符数组 & KMP 双指针搜索
- 字符数组：若干字符组成的有限序列，可理解为字符数组
- 双指针法：在数组、链表和字符串中很常用
- 反转系列：考察代码掌控能力，可先整体反转再局部反转
- 填充类题：预先给数组扩容到填充后大小，从后向前操作，降低复杂度
- KMP 算法：
  - 核心：当字符串不匹配时，利用已匹配文本避免从头匹配
  - 精髓：前缀表（next 数组），记录模式串前缀和后缀的最大公共长度
  - 前缀表：模式串与主串不匹配时，模式串回退位置
  - 时间复杂度：O(n+m)
  - next 数组：可为前缀表，或前缀表右移一位（初始为 -1）

#### 3.1.1 好题
- 翻转字符串里的单词（`StringBuilder`）
- 右旋转字符串
- 实现 `strStr()`
- 重复的子字符串

### 3.2 模式匹配
- 单模式单匹配：KMP
- 多模式单匹配：Trie
- 多模式多匹配：AC 自动机

## 4. 用回溯搜索

### 4.1 组合问题
- N 个数按一定规则找出 K 个数的集合
- 典型问题：
  - 组合
  - 括号生成（每个位置选或不选，符合规则）
  - 分割回文串（分割问题也是组合问题，切割线是组合过程）
  - 复原 IP 地址

### 4.2 切割问题
- 一个字符串按一定规则有几种切割方式

### 4.3 子集问题
- 每个元素可选或不选，无序
- N 个数的集合里有多少符合条件的子集
- 典型问题：
  - 子集（组合和分割问题收集树叶子节点，子集找所有节点）
  - 电话号码的字母组合
  - 组合总和（选或不选，或从答案出发用枚举逻辑）
  - 子集 II
  - 递增子序列（类似子集，但有陷阱）
  - 重新安排行程

### 4.4 排列问题
- 所有元素都要选，有序，用数组记录可选数字
- N 个数按一定规则全排列，有几种方式
- 典型问题：
  - 全排列（使用数组记录选择）
  - N 皇后
  - 解数独

### 4.5 棋盘问题 （二维回溯）
- 如 N 皇后、解数独等

## 5. 用 DP 搜！！！

### 5.1 状态
- 动态规划：每个状态由上一个状态推导，与贪心不同，贪心无状态推导
- 优化是必考点

### 5.2 注意事项
- DP 数组初始化
- 确定遍历顺序
- 举例推导 DP 数组数值
- 明确定义状态：确保每个 `dp[i]` 或 `dp[i][j]` 含义清晰
- 找准状态转移方程：核心，思考当前与前状态关系
- 初始化基础状态：设置初始条件
- 注意遍历顺序：如左到右或右到左
- 处理边界情况：数组空、单元素等
- 空间优化：二维 DP 可优化为一维
- 避免数组越界：确保引用索引有效
- 数据类型溢出：注意大数问题
- 子问题重叠：避免重复计算
- 记忆化搜索：自顶向下有时更直观

### 5.3 类型

#### 5.3.1 求最大/最值/方案数量
- 最大子数组：
  - `dp[i]` 表示以 `nums[i]` 结尾的最大子数组和
- 乘积最大的子数组
- 最长递增子序列 (LIS)：
  - 动态规划：O(n²)
  - 二分：蜘蛛纸牌
  - 贪心 + 二分：O(n log n)
  - 贪心策略：维护 `tails` 数组，`tails[i]` 为长度 i+1 递增子序列最小末尾
- 最长公共子序列 (LCS)：
  - 不要求连续，二维 DP，O(mn)
- 最长回文子序列
- 最长连续递增序列：
  - 连续元素递增，O(n)
- 最长连续序列：
  - 用哈希集合，O(n)
- 编辑距离
- 最长回文子串：
  - 连续，枚举子串长度或中心扩展，O(n²)
  - Manacher 算法：O(n)
- 最大子序和

#### 5.3.2 背包问题
- 0-1 背包：
  - n 件物品，背包容量 w，第 i 件重量 `weight[i]`，价值 `value[i]`，每件只能用一次，求最大价值
- 完全背包：
  - 零钱兑换，无限选取
  - 写法：外层枚举物品/体积，内层枚举体积/物品
- 二维 DP 数组 01 背包：
  - 先遍历物品或背包均可，内层从小到大
  - `dp[i][j]`：前 i 物品容量 j 最大价值
- 一维 DP 数组 01 背包：
  - 先物品后容量，内层从大到小
- 求组合数：外层遍历物品，内层背包
- 求排列数：外层背包，内层物品
- 求最小数：遍历顺序无所谓

#### 5.3.3 一维
- 爬楼梯

#### 5.3.4 二维
- 扩展至二维状态

#### 5.3.5 树形 DP
- 树结构上的动态规划

#### 5.3.6 数位 DP（数位动态规划）
- 解决区间 [l,r] 范围内满足约束的数字数量/总和/平方
- 写法：
  - 记忆化搜索：推荐，易编码，举一反三
  - 迭代：边界多，状态转移易错
- 好处：记搜占用机时少，适合比赛

#### 5.3.7 小欧字符串（Oppo）
- 具体问题需补充描述

# 搜索题总结

## 6. 用贪心搜！！！

### 6.1 贪心原理
- 每一步求局部最优解
- 策略：
  - 手动模拟，若模拟可行，可试贪心策略；若不可行，可能需动态规划
  - 举反例：若想不到反例，可尝试贪心
  - 贪心往往基于常识性推导，感觉“本应如此”
  - 贪心策略可能“部分正确”，部分测试用例可能失败
- 贪心模板：明确局部最优是什么
- 证明贪心：需证明局部最优导致全局最优

### 6.2 题型
- 跳跃游戏
- 分发饼干
- 摆动序列
- 最大子序和
- 买卖股票的最佳时机
- K 次取反后最大化的数组和
- 加油站
- 分发糖果
- 柠檬水找零
- 根据身高重建队列
- 根据身高重建队列（`vector` 原理讲解）
- 用最少数量的箭引爆气球
- 无重叠区间
- 划分字母区间
- 合并区间
- 单调递增的数字
- 监控二叉树

## 7. 其他类型

### 7.1 字典树
- 二十六叉树
- Trie 树：
  - 快速存储和查找字符串集合，又称字典树

## 8. 数论题

### 8.1 基础运算
- 位运算
- 快速幂

### 8.2 质数
- 常见质数：2、3、5 等
- 质数判定：
  - 试除法
- 质数筛选
- 质因数分解
- 互质判定：
  - GCD（最大公约数）

### 8.3 快速幂算法
- 高效计算大数幂

### 8.4 容斥原理
- 用于计数问题，解决交并补关系

### 8.5 组合数学题
- 恰好有 k 个 1 的子数组数量 = 至多有 k 个 1 的子数组数量 - 至多有 k-1 个 1 的子数组数量
- 模运算：
  - 常用模数：10^x + 7，多半是 1e9 + 7
  - 模大数/质数减少冲突
  - 例如：模 6 只可能出现 0、2、4；模 5 可出现 0、1、2、3、4
  - Hash 表取模也应模大质数，减少冲突，出题人常用此法降低“蒙对”概率
  - 模 1e9 + 7 优点：相加不爆 `int`，相乘不爆 `long long`

## 9. 并查集

### 9.1 优化
- 路径压缩优化：在查询（find）过程中，让树结构更扁平化，大幅提升查询和合并效率
- 平均复杂度：O(log2N)，性能优秀

### 9.2 适用场景
- 判断两个元素是否属于同一集合或群组（如好友关系、网络连接性）
- 动态计算图中连通块数量
- 快速实现“分组”操作，如“好友圈”问题

---

这个 Markdown 源代码包含所有你提供的“用贪心搜”“其他类型”“数论题”和“并查集”内容。如果需要进一步细化（如添加代码示例、图表或链接），请告诉我！



## 5. 具体题型

### 5.1 数组与排序相关
- 搜索旋转排序数组
- 合并区间（需要数学和逻辑）
- 螺旋数组
- 轮转数组（数学角度）
  - 多次翻转数组
- 除自身以外数组的乘积
- 缺失的第一个正数
- 矩阵置零
- 旋转矩阵（有三种方法）
- 搜索二维矩阵 II
- 删除问题：
  - 删除排序数组中的重复项
  - 删除有序数组中的重复项 II
