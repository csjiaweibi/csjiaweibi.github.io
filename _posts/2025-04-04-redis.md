---
title: 'Redis'
date: 2025-04-04
permalink: /posts/2025/04/blog-post-4/
tags:
  - cool posts
  - category1
  - category2
---

👉 [我的项目链接](https://github.com/csjiaweibi/Redis)

本项目分享我在学习 **Redis 源码与原理** 过程中的心得。

---

# 数据结构

## 字符串（String）
- 常见用途：缓存计数器、分布式锁、共享 Session 信息。
- 支持原子操作（INCR/DECR）。
- **SDS（简单动态字符串）**：
  - 记录字符串长度，获取复杂度 O(1)。
  - 自动扩容，避免缓冲区溢出。
  - 可存储二进制数据。

## 列表（List）
- 特点：有序，可重复，支持栈/队列操作。
- 底层实现：
  - Redis 3.2 前：双向链表、压缩列表。
  - Redis 3.2 后：统一由 `quicklist` 实现。
- 应用场景：消息队列、任务调度、文章列表。

## 集合（Set）
- 特点：元素唯一，无序，不支持索引。
- 底层实现：
  - 整数集合（intset）
  - 哈希表
- 应用场景：去重、点赞、标签系统、共同关注。

## 哈希（Hash）
- 特点：field-value 映射，适合存储对象。
- 底层实现：
  - 压缩列表（ziplist，已废弃）
  - 哈希表
  - Redis 7.0 起：listpack
- 应用场景：购物车、用户信息缓存。

## 有序集合（ZSet）
- 每个元素绑定一个 score，自动排序。
- 底层实现：
  - 压缩列表（7.0 后为 listpack）
  - 跳表（skiplist）
- 应用场景：排行榜、实时评分、任务调度。

### 跳表特点
- 时间复杂度：查找/插入/删除 O(log n)。
- 空间复杂度：O(n)。
- 依赖随机化保持平衡，实现简单。

## BitMap
- 特点：二值状态存储（0/1）。
- 应用场景：签到、登录状态统计。
- 常用命令：`SETBIT`、`GETBIT`、`BITCOUNT`。

## HyperLogLog
- 特点：极低内存统计基数，误差 ~0.81%。
- 应用场景：UV 统计、大规模去重。
- 常用命令：`PFADD`、`PFCOUNT`、`PFMERGE`。

## Stream
- Redis 5.0 引入，消息流结构。
- 特点：支持全局唯一 ID、消费组。
- 应用场景：消息队列、日志系统。

## GEO
- Redis 3.2 引入。
- 应用场景：存储地理位置，如滴滴叫车。

---

# 底层架构

## 单机模式
- 部署简单、性能高。
- 缺点：可靠性差，QPS ~几万，单机受 CPU 约束。

## 主从模式
- Master 写，从节点读。
- 优点：读写分离，提升吞吐。
- 缺点：写能力、存储能力受单机限制；故障切换需人工干预。

## 哨兵模式（Sentinel）
- 功能：监控、通知、自动故障转移。
- 核心机制：
  - 主观下线（SDOWN）
  - 客观下线（ODOWN）
  - 仲裁（quorum）
- 优点：自动切换，提高可用性。
- 缺点：仍未解决写压力，切换存在延迟。

## 集群模式（Cluster）
- Redis 3.0 引入，分布式存储。
- 特点：
  - 无中心架构，至少 6 节点（3 主 3 从）。
  - Gossip 协议维护节点信息。
  - 分片机制（hash slot）。
- 优点：高可用、可扩展。
- 难点：动态扩容复杂、一致性处理。

---

# 缓存设计

## 分布式锁
- `SETNX + EXPIRE` 实现。
- 问题：死锁、误删、续期。
- 解决：
  - 线程 ID 对比。
  - Lua 脚本保证原子性。
  - 看门狗机制实现锁续期。

## 缓存问题

### 缓存穿透
- 原因：查询不存在的数据。
- 解决方案：
  - 缓存空值
  - 布隆过滤器

### 缓存击穿
- 原因：热点 Key 过期，大量请求打到数据库。
- 解决方案：
  - 永不过期 + 定时更新
  - 分布式锁（互斥锁）
  - 逻辑过期

### 缓存雪崩
- 原因：大量 Key 同时过期。
- 解决方案：
  - 过期时间随机化
  - 多级缓存
  - 缓存预热
  - 高可用集群
  - 降级策略

### 缓存不一致
- 典型方案：
  - 延时双删
  - Binlog 异步更新 Redis
  - 消息队列（保证最终一致性）

---

# 持久化策略

## RDB
- 快照方式，fork 子进程写磁盘。
- 优点：恢复快，文件紧凑。
- 缺点：丢失快照间数据。

## AOF
- 记录写操作日志。
- 同步策略：
  - always / everysec / no
- 优点：安全性高，可读。
- 缺点：文件大，恢复慢。

## 混合持久化
- Redis 4.0 引入，结合 RDB + AOF 优势。

## 过期删除策略
- **惰性删除**：访问时检查。
- **定时删除**：过期立即删除。
- **定期删除**：后台周期清理。

## 内存淘汰策略
- 常见策略：
  - volatile-lru / allkeys-lru
  - volatile-lfu / allkeys-lfu
  - 随机删除（random）
  - noeviction（报错）

---

# 高可用

- **主从复制**
- **哨兵模式**
- **切片集群**

## 节点健康检查方式
1. `PING` → 返回 `PONG`。
2. `INFO` → 查看运行状态。
3. `CLUSTER INFO` → 检查集群状态。
4. Telnet/Netcat → 测试端口。
5. 监控工具（Prometheus/Grafana）。

---

# 高性能

## 单线程模型
- 主线程处理：请求解析 → 数据读写 → 响应。
- 后台线程（BIO）：
  - 文件关闭
  - AOF 刷盘
  - 异步内存释放（unlink/flushdb async）

## 多路 I/O 复用
- 使用 epoll/select。
- 单线程处理多客户端请求。

---

# 实际应用

- **优惠券系统**：计数器 + Lua 脚本。
- **全局 ID 生成器**：避免规律性，突破单表限制。
- **达人探店**：
  - List：点赞列表
  - SortedSet：点赞排行榜
- **附近商户**：GEO
- **UV 统计**：HyperLogLog
- **用户签到**：BitMap

---

# 一致性

## Redis 与 MySQL 数据一致性方案

1. **直接操作数据库与缓存**
   - 六种方式：
     - 先写 MySQL 再写 Redis（风险大）
     - 先写 Redis 再写 MySQL（可能丢数据）
     - 先删 Redis 再写 MySQL
     - 先删 Redis → 写 MySQL → 再删 Redis
     - 先写 MySQL 再删 Redis（常用）
     - **Binlog 异步更新 Redis（推荐）**

2. **消息队列（Kafka）**
   - 写入数据时同时写入消息队列，消费者同步更新缓存。
   - 保证最终一致性。

3. **TCC 分布式事务**
   - Try → Confirm → Cancel。
   - 适合金融交易等强一致场景。

4. **Canal 等中间件**
   - 监听 MySQL Binlog，实时同步到 Redis。
   - 常用于实时大屏等场景。

---

