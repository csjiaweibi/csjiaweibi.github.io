---
title: 'MQ'
date: 2025-04-04
permalink: /posts/2025/04/blog-post-5/
tags:
  - cool posts
  - category1
  - category2
---

👉 [我的项目链接](https://github.com/csjiaweibi/MQ)


# RabbitMQ 消息队列

## RabbitMQ 特点
RabbitMQ 是一种基于 **AMQP（高级消息队列协议）** 的开源消息中间件，常用于分布式系统中的 **异步通信、削峰、解耦**。

主要特点：

1. **高可靠性**：支持消息持久化、确认机制、事务机制。
2. **路由灵活**：通过交换机和绑定规则，支持直连、广播、主题等模式。
3. **高可用性**：支持集群部署和镜像队列。
4. **可扩展**：应对高并发，支持插件扩展。
5. **多协议支持**：兼容 AMQP、STOMP、MQTT。
6. **多语言客户端**：提供 Java、Python、.NET 等库。
7. **管理界面**：Web 控制台，方便监控和管理。
8. **插件丰富**：支持消息追踪、性能监控等。

---

## 消息队列模型

### 发送消息流程
1. 建立 **TCP 连接** 与 **Channel**。
2. 声明 **交换机** 与 **队列**。
3. 通过 **BindingKey** 绑定交换机与队列。
4. 生产者将消息（RoutingKey、目标 Exchange、Payload 等）发送至 Broker。
5. 交换机根据路由规则存储到队列。
6. 生产者释放资源（一般复用长连接）。

### 接收消息流程
1. 消费者建立 **连接与 Channel**。
2. 声明 **队列**。
3. 绑定交换机与队列。
4. 消费者开始消费消息（同步 / 异步）。
5. 消费者接收消息并处理。
6. **消息确认机制**：
   - 手动确认（ack）
   - 自动确认
   - 失败时可 nack（重新入队或丢弃）。
7. 处理失败的消息可进入 **死信队列**。
8. 释放连接（通常复用）。

---

## 消息有序性

### RabbitMQ
- **多个队列 + 单消费者**：每个队列内部保持顺序。
- **单队列 + 单消费者**：保证顺序，消费者内部用内存队列 + worker 并发处理。

### 操作系统消息队列
1. **FIFO**：POSIX/System V 默认先进先出。
2. **单生产者-消费者**：天然保证顺序，多线程需互斥锁。
3. **优先级**：高优先级可能破坏严格 FIFO。
4. **业务层控制**：加序号、分组、校验。
5. **对比应用层 MQ**：OS 消息队列适用于单机 IPC，RabbitMQ/Kafka 适用于分布式。

---

## 架构

### 核心组件
1. **Producer（生产者）**：发送消息到交换机。
2. **Consumer（消费者）**：从队列拉取消息并处理。
3. **Exchange（交换机）**：负责消息路由，不存储消息。
4. **Binding**：交换机与队列的绑定关系。
5. **Queue（队列）**：存储消息，FIFO。
6. **Broker**：RabbitMQ 服务节点，管理交换机、队列、路由。

### 交换机类型
- **Direct**：路由键精准匹配。
- **Fanout**：广播到所有绑定队列。
- **Topic**：支持通配符 `*`、`#`。
- **Headers**：根据消息头属性路由。

---

## 高效读写

### 消息不丢失机制
**1. 生产者 → RabbitMQ**
- **事务机制**：可靠但性能低。
- **Confirm 机制**：轻量，性能高，推荐。

**2. RabbitMQ 内部**
- **持久化**：消息 `deliveryMode=2` + durable 队列。
- **集群/镜像模式**：多节点同步，避免单点故障。

**3. RabbitMQ → 消费者**
- **BasicAck**：手动确认，失败自动重投递。
- **死信队列（DLQ）**：存放多次消费失败的消息。
- **消息补偿机制**：定时任务重试，保证最终一致性。

---

## 待补充模块

- **刷盘机制**
- **死信队列详解**
- **生产消费模型**
- **交换机模型**
- **延迟队列**
- **消息持久化**
- **Java API 操作**
- **集群搭建**
