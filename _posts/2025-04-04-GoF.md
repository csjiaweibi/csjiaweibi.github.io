---
title: '设计模式'
date: 2025-04-04
permalink: /posts/2025/04/blog-post-3/
tags:
  - 设计模式
---


设计模式体现了程序员对于代码优雅的追求




非常用力地去思考，你能给这个世界带来的价值是什么，找到方向后努力去尝试，多去见你的前辈，跟他们学习，多去学习你所在领域的知识，勇敢去冒险，要敢于牺牲一些东西，如果失败了也没关系，换一种方式继续做，我认为一个人越早去尝试，后面会做得越好。
不要还是用面向过程的思想去写OOP

面试官形容一个场景，你讲这是啥模式比如更新迭代的系统用什么模式好像是适配器模式吧然后讲一些你自己用过的或者了解的模式

# 需要做的事
- 能不能用设计模式去重写之间的项目代码

# 设计模式学习心得体会

### 单一职责原则   （控制粒度）
- 就一个类而言，应该仅有一个引起它变化的原因。
- 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
- 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。
- 如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。
- 面向对象的设计其实就是希望做到代码的责任分解。  

### 开放–封闭原则   （热拔插）
- 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
- 软件实体（类、模块、函数等等）应该可以扩展，但不可修改。
- 对于扩展时开放的，对于更改是封闭的。
- 怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？开放-封闭原则给出了答案。
- 何时应对变化：
  - 无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生变化的种类，然后构造抽象来隔离那些变化。
  - 等到变化发生时立即采取行动。在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
  - 我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。
- 开发-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频率变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。

### 里氏代换原则
- 子类型必须能够替换掉它们的父类型。
- 一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，出现的行为没有变化。
- 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
- 由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。

### 依赖倒置原则 会修电脑（接口）不会修收音机
- **定义**：
  - 高层模块不应该依赖底层模块。二者都应该依赖抽象。
  - 抽象不应该依赖细节，细节应该依赖抽象。
- **核心思想**：针对接口编程，不要对实现编程。
- **意义**：依赖倒置原则可以说是面向对象设计的标志。用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计。

### 接口隔离原则
- 使用多个隔离的接口，比是由单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便.(降低依赖，降低耦合)。
- 根据接口隔离原则，当一个接口太大的时候，我们就需要将它分割为一些更加细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。

### 迪米特法则 没熟人难办事？找管理就成
- **最少知识原则**：
  - 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
  - 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。即不需要让类知道的字段或行为就不要公开（private）。
- **根本思想**：强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成设计。



### 合成复用原则
- 尽量使用合成/聚合，尽量不要使用类继承
- 好处是 优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物
- 将抽象部分与它的实现部分分离，使它们都可以独立地变化
- 实现指的是抽象类和它的派生类用来实现自己的对象
- 实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合
- 只要真正深入地理解了设计原则，很多设计模式其实就是原则的应用而已，或许在不知不觉中就在使用设计模式了





## 设计模式分类与核心模式解析

## 一、创建型模式（Creational Patterns）
主要解决对象创建问题，隐藏创建细节，提升系统灵活性：

 单例模式
- **定义**：确保全局唯一实例（如配置管理器），保证一个类只有一个实例，并提供一个访问它的全局访问点。
- **实现方式**：
  - **饿汉式单例类**：静态初始化，在自己被加载时就将自己实例化。
  - **懒汉式单例类**：静态初始化，在第一次被引用时，才会将自己实例化。
- **优点**：单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问以及何时访问它。简单地说就是对唯一实例的受控访问。

 简单工厂模式
- 设计计算器的例子，可以定义一个运算类的简单工厂，所谓的工厂就是用一个单独的类来实现创造实例的过程，输入要求，生成实例
- **定义**：用一个单独的类来做动态创造实例的过程，通过子类决定实例化对象（如数据库连接工厂）。
- **优点**：最大的优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。

 工厂方法模式
- 如支付系统返回不同的支付方式
- **定义**：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
- **优点**：使用了多态性，保持了简单工厂模式的优点（保持封装对象创建过程），而且克服了它的缺点（违背开放-封闭原则）。
- 当需要根据参数创建不同类型的对象时，例如创建不同类型的支付网关（支付宝、微信支付）。
- **缺点**：每加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。

抽象工厂模式
- 反射 IOC 依赖注入
- **定义**：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。创建产品族（如跨平台UI组件库）。
- **优点**：
  - 易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品。
  - 让具体的创建实例过程与客户端分离，客户端通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中。
- **缺点**：改动较大，可以用简单工厂来改进抽象工厂。

建造者模式
- 肯德基与麦当劳的规范化 规范过程  使得子类必须重写方法
- **定义**：分步构建复杂对象（如SQL查询构造器）。通过指挥者制定最后执行什么方法
- **优点**：
  - 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
  - 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。
  - 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式

 原型模式
- 简历复制 
- **定义**：通过克隆创建对象（如游戏角色复制），分为浅复制与深复制。
- **优点**：
  - 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
  - 一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，又对性能是大大的提高。




##  二、结构型模式（Structural Patterns）
处理类/对象组合关系，优化系统结构：

 适配器模式
- 翻译官的作用 通过适配器模式解决接口之间不匹配的问题 就像换了一个电池充电器一样
- **定义**：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- **类型**：
  - **类适配器模式**：用到多重继承。
  - **对象适配模式**：通过组合的方式实现。
- **优点**：
  - 系统的数据和行为都正确，但接口不符时，适配器模式可以使得控制范围之外的一个原有对象与某个接口匹配。
  - 主要应用于希望复用一些现存的类，但接口又与复用环境要求不一致的情况。


 桥接模式
- 手机软件如何统一
- **定义**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- **优点**：
  - 实现了抽象和实现的解耦。
  - 可以独立地改变抽象部分和实现部分。

 过滤器模式
- 
- **定义**：
- **优点**：


 组合模式
- 分公司 = -部门
- **定义**：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
- **优点**：
  - 用户可以一致地使用组合结构和单一对象。
  - 定义了包含基本对象和组合对象的类层次结构，简化了客户端代码。


 装饰器模式
- 用换衣服作为例子，
- **定义**：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。
- 嵌套调用：在装饰器模式中，如果有多个装饰器（例如，A装饰B，B装饰C），调用链可能会看起来像是递归，因为每个装饰器都会调用下一个对象的同名方法。这种嵌套调用形成了一个链式结构，但它并不是真正的递归（递归是指方法自己调用自己）。
- **优点**：
  - 装饰模式是利用SetComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。
  - 把类中的装饰功能从类中搬移去除，这样可以简化原有的类。
  - 有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。
  - 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活
需要把所需的功能按正确的顺序串联起来进行控制
  - 把类中的装饰功能从类中搬移去除，这样可以简化原有的类
  - 有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑
  - Java的I/O系统大量使用了装饰器模式。例如，BufferedReader和BufferedWriter是对Reader和Writer的装饰，它们通过装饰器为输入输出流添加了缓冲功能。


 外观模式
-  基金与股票  典型的三层结构的来源
-  电商平台的订单系统对外提供简单接口，而内部涉及多模块协作。
- **定义**：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- **优点**：
  - 在设计初期阶段，应该有意识地将不同的两个层分离，层与层之间建立外观Facade。
  - 在开发阶段，子系统因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。

  
 享元模式    项目多也别傻做
- **定义**：运用共享技术有效地支持大量细粒度的对象
- **优点**：内部状态与外部状态
  - 内部状态：享元对象内部并且不会随着环境改变而改变的共享部分，ConcreteFluweight
  - 外部状态：随环境改变而改变的、不可以共享的状态
  - 享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来显示数据。如果能发现这些实例除了几个参数外基本都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数量
- 应用
  - 如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式


 代理模式
- 借助别人实现任务
- **定义**：为其他对象提供一种代理以控制对这个对象的访问。  rpc 
- **类型**：
  - **远程代理**：为一个对象在不同的地址空间提供局部代表。
  - **虚拟代理**：根据需要创建开销很大的对象。
  - **安全代理**：用来控制真实对象访问时的权限。
  - **智能指引**：指当调用真实对象时，代理处理另外一些事。


##  三、行为型模式（Behavioral Patterns）
解决对象间交互与职责分配：


 责任链模式
- **定义**：请求传递链（如审批流程）。
- **优点**：可以将请求的发送者和接收者解耦，使多个对象都有机会处理请求。

 命令模式
- **定义**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作
- **优点**：第一 能较容易地设计一个命令队列
  - 第二 在需要的情况下，可以较容易地将命令记入日志
  - 第三 允许接收请求的一方决定是否要否决请求
  - 第四 可以容易地实现对请求的撤销和重做
  - 第五 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易
  - 敏捷开发原则告诉我们们不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义
  
 解释器模式
- **定义**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来接收语言中的句子。要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题
- **优点**：
  - 好处：当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式
  容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些都易于直接编写
  - 不足：为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理

 迭代器模式
- **定义**：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
- **优点**：
  - 分离了集合对象的遍历行为，抽象出一个迭代器来负责。
  - 不暴露集合的内部表示，同时可以让外部代码透明地访问集合内部的数据。
  
 中介者模式
- **定义**：尽管将一个系统分割成许多对象通常可以增加其复用性，但是对象间的相互连接的激增又会降低其可复用性
大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所有，对系统的行为进行任何较大的改动就十分困难了
- **优点**：
  - 一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合
  - 当系统出现了‘多对多’交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理
  - 优先 Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator。由于把对象如何协作进行了抽象，将中介作为一个独立的概念年并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏伟的角度去看待系统
  - 由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就是使得中介者会变得比任何一个ConcreteColleague都复杂

 备忘录模式
- 保存游戏时候的状态
- **定义**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保持这个状态。这样以后就可将该对象恢复到原先保持的状态。
- **优点**：
  - 把要保存的细节封装在Memento中，便于后续修改。
  - 适用于功能复杂且需要维护或记录属性历史的类。

 观察者模式
- 前台报警人
- 又叫发布-订阅模式
- 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己
- 所有的控件都是实现了观察者模式
- **定义**：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。
- **优点**：
  - 将一个系统分割成一系列相互协作的类，避免了为了维持一致性而使各类紧密耦合。
  - 适用于一个对象的改变需要同时改变其他对象，但不知道具体有多少对象有待改变的情况。

状态模式
- **定义**：当一个对象的内在状态改变时允许改变其行为，这个对象看起来是改变了其类。
- **优点**：
  - 将与特定状态的行为局部化，并且将不同状态的行为分割开来。
  - 可以很容易地增加新的状态和转移。


 空对象模式
- **定义**：
- **优点**：
  

 策略模式
- 商场促销场景下，定义不同的促销方案，促销方案本身就是变化点，封装变化点，策略与简单工厂结合，与Context结合。
- **定义**：定义了算法家族，分别封装起来，让它们之间可以互相替换，此策略让算法的变化，不会影响到使用算法的客户。
- **优点**：
  - 简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。
  - 可以用来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
  - 策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性
  - 当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategu类中，可以在使用这些行为的类中消除条件语句
  - 任何需求的变更都是需要成本的


模板模式
- **定义**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
- **优点**：
  - 提供了一个很好的代码复用平台。
  - 当不变的和可变的行为在方法的子类实现中混合在一起的时候，模板方法模式可以把不变行为搬迁到单一的地方，帮助子类摆脱重复的不变行为的纠缠。
  - 网页加载的通用模板，子类实现具体内容。


访问者模式
- **定义**：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作
- **优点**：
  - 适用于数据结构相对稳定的系统。它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化
  - 目的是要把处理从数据结构分离出来。如果系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较适合的，因为访问者模式使得算法操作的增加变得容易
  - 优点是 增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中
  - 缺点是 使增加新的数据结构变得困难了




## J2EE 模式

 MVC 模式（MVC Pattern）
- **定义**：将应用程序分为三部分：模型（Model）、视图（View）和控制器（Controller）。模型负责数据和业务逻辑，视图负责显示数据，控制器处理用户输入并更新模型和视图。
- **优点**：分离关注点，便于维护和扩展。
- **应用场景**：Web 应用程序开发，如 Struts 框架。

 业务代表模式（Business Delegate Pattern）
- **定义**：用来减少客户端与业务服务层之间的耦合。业务代表（Business Delegate）充当客户端和业务服务的中间层。
- **优点**：隐藏业务服务的复杂性，提高代码可重用性和可维护性。
- **应用场景**：企业应用中需要屏蔽底层服务的复杂实现。

 组合实体模式（Composite Entity Pattern）
- **定义**：将多个相关实体组合成一个更大的实体对象，以便于管理和维护。
- **优点**：简化复杂对象之间的关系，提高数据一致性。
- **应用场景**：需要处理一组相关对象（如订单和订单详情）的情况。

 数据访问对象模式（Data Access Object Pattern）
- **定义**：将数据访问的代码与业务逻辑分离，通过数据访问对象（DAO）来处理数据库操作。
- **优点**：提高代码的可重用性和可测试性，隔离数据访问细节。
- **应用场景**：数据库操作、文件操作等数据持久化场景。

 前端控制器模式（Front Controller Pattern）
- **定义**：提供一个统一的入口点来处理所有传入的请求，通常由一个 servlet 或控制器负责。
- **优点**：集中处理请求，简化流程管理，提高可维护性。
- **应用场景**：Web 应用程序中的请求分发和处理，如 Spring MVC。

 拦截过滤器模式（Intercepting Filter Pattern）
- **定义**：在请求处理前后执行一些通用操作（如认证、日志记录），通过过滤器链来实现。
- **优点**：解耦请求处理和横切关注点（如安全检查）。
- **应用场景**：Web 应用程序中的安全控制、日志记录等。

 服务定位器模式（Service Locator Pattern）
- **定义**：提供一个中心化的方式来查找和使用服务，减少客户端直接依赖服务对象的需要。
- **优点**：简化服务查找，减少代码重复。
- **应用场景**：JNDI 查找、EJB 服务定位等。

 传输对象模式（Transfer Object Pattern）
- **定义**：用来封装和传输数据，通常用于客户端和服务器之间传递业务数据。
- **优点**：减少网络调用次数，提高性能。
- **应用场景**：远程方法调用（RMI）、Web 服务数据传输。

 生产者消费者模式
- 生产者消费者设计模式是一种用于多线程环境下协调数据生产与消费的并发设计模式，通过引入一个共享缓冲区（如阻塞队列）实现生产者与消费者之间的解耦，从而提升系统的整体性能和资源利用率。接下来，我会讲述其生产与消费的详细过程。
- 当生产者生成数据时，首先，生产者根据业务逻辑产生数据，并调用缓冲区提供的接口将数据放入队列中；如果缓冲区已满，生产者会被阻塞，等待空闲空间出现。其次，消费者不断地从缓冲区中获取数据进行处理；当缓冲区为空时，消费者同样会进入等待状态，直至有新数据被生产者放入。然后，通过内部的同步机制（如锁、信号量或者直接使用阻塞队列），确保在并发环境下生产者和消费者对共享数据的访问是安全的，不会出现数据竞争或丢失。最后，随着数据不断地被生产和消费，整个系统实现了生产与消费的有效解耦，不仅提升了并发处理能力，还能灵活应对生产速度和消费速度不匹配的情况，从而保证系统在高并发场景下稳定运行。

 Future模式
- 核心思想是异步调用，主要用在多线程领域，并非Java语言独有。
- 在Java中，Future类只是一个泛型接口，位于java.util.concurrent包下，其中定义了5个方法，主要包括下面这4个功能：
  - 取消任务；判断任务是否被取消;判断任务是否已经执行完成;获取任务执行结果。




## 学习心得与建议

 1. 学习路径优化
- **先看《大话设计模式》** ：通过故事化案例建立直观认知（如"小菜学编程"系列）   
- **结合UML图理解**：绘制类图理清模式结构关系（推荐PlantUML工具）  
- **代码实战三阶段**：① 模式Demo复现 → ② 框架源码分析（如Spring的单例/代理模式） → ③ 业务场景改造   

 1. 常见误区规避
- **模式≠银弹**：避免在10行代码里强用3个模式，需评估复杂度  
- **关注本质而非实现**：如观察者模式核心是解耦发布-订阅关系，而非特定实现类  
- **警惕过度设计**：优先满足开闭原则（OCP），再考虑模式应用  

 1. 推荐学习组合
1. **理论书籍**：《大话设计模式》（入门）→《设计模式：可复用面向对象软件的基础》（进阶）   
2. **视频课程**：李建忠《C#设计模式纵横谈》（配套《大话》案例扩展） 
3. **实践项目**：  
   - 简易RPC框架（涉及代理/工厂/观察者模式）  
   - 工作流引擎（应用责任链/状态/模板方法模式）  

---

> 学习感悟：设计模式如同编程领域的成语，初期需要刻意记忆"固定搭配"，但随着实践积累，最终应达到"信手拈来而不拘泥形式"的境界。真正重要的不是记住23种模式，而是培养出在复杂问题中识别模式特征的眼力   。
